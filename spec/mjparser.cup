
package rs.ac.bg.etf.pp1;
import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected;

	Logger log = Logger.getLogger(getClass());
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);	
	}
	
	public void syntax_error(Symbol cur_token){
		report_error("\nSintaksna greska", cur_token);	
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);	
	}
	
	public void report_error(String message, Object info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
			msg.append(" na liniji ").append( ((Symbol)info).left );		
		log.error(msg.toString());
	}
	
:}

init with {:
	errorDetected = false;
:}

/* za presretanje lexera kad god vrati jedan token */
scan with {:
	Symbol s = this.getScanner().next_token();
	if( s!=null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, ENUM, CONST, PRINT, READ, RETURN, NEW;
terminal PLUS, MINUS, MUL, DIV, MOD, INC ,DEC, EQUAL;
terminal DOT, SEMI, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal VOID;
terminal String IDENT;
terminal Integer NUMBER;
terminal boolean BOOL;
terminal String CHARCONST;
terminal IF, ELSE, FOR, BREAK, CONTINUE, OR, AND, EQ, NE, GR, GRE, LS, LSE;


nonterminal Statement, StatementList, DesignatorStatement;
nonterminal SignedTerm, Factor, Instantiation;
nonterminal Addop, Mulop;
nonterminal Program, Type;
nonterminal InstPrimitive;
nonterminal VarDeclList, MethDeclList, VarDecl, MultipleVarDecl, MultipleVarDeclExpr, MethDecl, ArrayDecl,  EnumExpr, EnumExprList, EnumInst;
nonterminal PrintStmt, PrintParam;
nonterminal Return, OptionalExpr;
nonterminal ConstExpr, ConstInitializationList, ConstDecl;
nonterminal GlobalDeclList, GlobalDecl,  GlobalVarDecl;
nonterminal ParameterList, Parameter, ArgList, OptionalArgs;
nonterminal MethType, EnumDecl, FuncCallName;
nonterminal InstArrayInitList, InstArrayInitNode, InstArrayInit;
nonterminal PreHookUpCall;
nonterminal AbstractCondition, AbstractConditionalStatement, ConditionalStatement, Condition, CondTerm, CondFact, RelOp, FirstCondFact, SecondCondFact, IfStatement, ElseStatement, StartOfIfStatement;
nonterminal ForLoopStatement, OptionalForPrecondition, OptionalForCondition, OptionalForPostcondition, StartOfForLoop;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, EnumBegin, EnumUse, MethBegin;
nonterminal rs.etf.pp1.symboltable.concepts.Obj VarUse, MyArray, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Term;
nonterminal rs.etf.pp1.symboltable.concepts.Obj FuncCall;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MyArrayName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj InstArray;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr, InstPrimitiveType;

precedence left ELSE;

Program   ::= (Program) PROG ProgName:progName GlobalDeclList LBRACE MethDeclList RBRACE;

ProgName ::= (ProgName) IDENT:progName;

GlobalDeclList ::= (GlobalDeclListProduction) GlobalDeclList GlobalDecl
				|  /* epsilon */
				;

GlobalDecl ::= (GVarDeclList) GlobalVarDecl
			|  (GEnumDeclList) EnumDecl
			|  (GConstDeclList) ConstDecl
			;

GlobalVarDecl  ::=  (GVarDecl) VarDecl
				| 	(GlobalVarDeclErrorComma) error COMMA:l {: parser.report_error("Izvrsen oporavak do prvog ',' u deklaraciji promenljive", null); :} 
				|   (GlobalVarDeclErrorSemi) error SEMI:l {: parser.report_error("Izvrsen oporavak do prve ';' u deklaraciji promenljive", null); :} 
				;

VarDeclList ::= (VarDeclListProduction) VarDeclList VarDecl
			| /* epsilon */
			;
			
MultipleVarDeclExpr ::= (SimpleVarDecl) IDENT:varName
					|   (SimpleArrayDecl) ArrayDecl
					;
					 			
MultipleVarDecl ::= (MultipleVarDeclProduction) MultipleVarDeclExpr COMMA MultipleVarDecl
				| 	(SingleVarDeclProduction) MultipleVarDeclExpr
				; 

VarDecl  ::= (MultipleVariableDecl) Type:varType MultipleVarDecl SEMI
		 ;

MethDeclList ::= (MethDeclListProduction) MethDeclList MethDecl
            |   /* epsilon */
			;

OptionalExpr ::= (OptionalExprProduction) Expr 
			 | /* epsilon */
			 ;

Return ::=  (ReturnProduction) RETURN OptionalExpr SEMI
				;
				
Parameter ::= (ParameterVarProduction) Type IDENT:paramName
			| (ParameterArrayProduction)  Type ArrayDecl
			;
				
ParameterList ::= (MultipleParameterListProduction) Parameter COMMA ParameterList
			  |   (SingleParameterListProduction) Parameter
			  |   (ParameterListErrorComma) error COMMA:l {: parser.report_error("Izvrsen oporavak do prvog ',' u deklaraciji formalnog parametra", null); :}
			  |   (ParameterListErrorRparen) error RPAREN:l {: parser.report_error("Izvrsen oporavak do prve ')' u deklaraciji formalnog parametra", null); :} 
			  |   /* epsilon */
			  ;

MethType ::= (NonVoidMethType) Type
		 |	 (VoidMethType) VOID 
		 ;				

MethBegin ::= (MethBegin) MethType IDENT:methodName;

MethDecl ::= (MethDecl) MethBegin LPAREN ParameterList RPAREN VarDeclList LBRACE StatementList RBRACE
		 ;

ArrayDecl ::= (ArrayDecl) IDENT:arrayName LBRACKET RBRACKET ;

ConstExpr ::= (ConstExprNumber) IDENT:constIdent EQUAL NUMBER:constValue
			| (ConstExprBool) IDENT:constIdent EQUAL BOOL:constValue
			| (ConstExprChar) IDENT:constIdent EQUAL CHARCONST:constValue
			;

ConstInitializationList ::= (MultipleConstExpr) ConstExpr COMMA ConstInitializationList
						|   (SingleConstExpr) ConstExpr
						;						

ConstDecl ::= (ConstDecl) CONST Type ConstInitializationList SEMI;

EnumInst ::= (EnumConstValue) EQUAL NUMBER:enumConstantValue
			| (NoEnumInst) /* epsilon */
			;

EnumExpr ::= (EnumExpr) IDENT:enumConstantName EnumInst;

EnumExprList ::= (MultipleEnumExpr) EnumExpr COMMA EnumExprList 
			 | (SingleEnumExpr) EnumExpr
			 ;
EnumBegin ::= (EnumBegin) ENUM IDENT:enumName;			 
EnumDecl ::= (EnumDecl) EnumBegin LBRACE EnumExprList RBRACE;

StatementList ::= (StatementListProduction) StatementList Statement
				|  /* epsilon */
				;
PrintParam ::= (PrintParamProduction) COMMA NUMBER
			|   /* epsilon */
			;
PrintStmt ::=  (PrintStmtProduction) PRINT LPAREN Expr:printExpr PrintParam RPAREN 
			;
		
Statement ::=	(DesigStatement) DesignatorStatement SEMI
			|	(Cond) AbstractConditionalStatement
			|	(For) ForLoopStatement
			|   (BreakProduction) BREAK SEMI
			|   (ContinueProduction) CONTINUE SEMI
			|   (InnerStatementProd) LBRACE StatementList RBRACE
		  	|   (ReadCall) READ LPAREN Designator RPAREN SEMI
		  	|	(PrintCall) PrintStmt SEMI
		  	|   (MethCall) FuncCall SEMI
		  	|   (ReturnStatement) Return
		    ;

ArgList ::= (ArgumentListProduction) ArgList COMMA Expr
		| (ArgumentListExprProduction) Expr
		;
		
OptionalArgs ::= (OptionalArgsProduction) ArgList
			 | 	/* epsilon */
			 ;
			 
FuncCallName ::= (FuncCallName) IDENT:funcName LPAREN;
		
FuncCall  ::=  (FuncCall)  FuncCallName OptionalArgs RPAREN;

DesignatorStatement ::=  (DesStatAssignment) Designator EQUAL Expr
					  |  (DesStatAssignmentError) error:l {: parser.report_error("Izvrsen oporavak u naredbi dodele do prve ';' " , null); :}
					  |	 (DesStatInc) Designator INC
					  |	 (DesStatDec) Designator DEC
					  ;

Expr ::=(AddopExpr) Expr Addop Term
	 |  (TermExpr) SignedTerm
	 ;

SignedTerm ::= (MinusTerm) MINUS Term
			|  (PlusTerm) Term
			;							 

Term ::=  (MulopTerm) Term Mulop Factor
	 |  (FactorTerm) Factor
	 ;

Type ::=  (TypeProduction) IDENT:typeName;

PreHookUpCall ::= (PreHookUpCallProduction) /* epsilon */;

InstArrayInitNode ::= (InstArrayInitNodeProduction) PreHookUpCall Expr;

InstArrayInitList ::= (InstArrayInitListProduction) InstArrayInitList COMMA InstArrayInitNode
					| (InstArrayInitListNodeProduction) InstArrayInitNode
					;

InstArrayInit ::= (InstArrayInitProduction) LBRACE InstArrayInitList RBRACE
				  |(InstArrayInitNoProduction)  /* epsilon */ 
				  ;

InstPrimitive ::= (InstPrimitiveProduction) NEW Type;

InstPrimitiveType ::= (InstPrimitiveTypeProduction) InstPrimitive LBRACKET Expr;

InstArray  	  ::= (InstArrayProduction) InstPrimitiveType RBRACKET InstArrayInit;

Instantiation ::= (InstArr) InstArray;
		
Factor ::= (IdentFactor) VarUse
		 | (NumberFactor) NUMBER
		 | (CharFactor) CHARCONST
		 | (BoolFactor) BOOL
		 | (InstFactor) Instantiation
		 | (ArrayFactor) MyArray
		 | (EnumUseFactor) EnumUse
		 | (FuncCallFactor) FuncCall
		 | (GroupFactor) LPAREN Expr RPAREN
		 ;
		 
VarUse ::= (VarUse) IDENT:varName;
		
MyArrayName ::= (MyArrayName) IDENT:arrName LBRACKET;

MyArray  ::= (MyArray) MyArrayName Expr RBRACKET;		

EnumUse   ::= (EnumUse) IDENT:enumName DOT IDENT:enumConst;
		
Designator	::=	(IdentDesignator) VarUse
			|   (MyArrayDesignator) MyArray
			;
		
Addop  ::= (PlusAddop) PLUS 
		|  (MinusAddop) MINUS
		;

Mulop  ::= (MulMulop) MUL
		|  (DivMulop) DIV
		|  (ModMulop) MOD
		;
			
StartOfIfStatement ::= (StartOfIfStmtProduction) IF LPAREN;
IfStatement ::= (IfStatementProduction) StartOfIfStatement AbstractCondition RPAREN Statement ;
ElseStatement ::= (ElseStatementProduction) IfStatement ELSE;

AbstractConditionalStatement ::= (AbstractConditionalStatementProduction) ConditionalStatement;
ConditionalStatement ::= (ConditionalIfStatementProduction) IfStatement
				     |   (ConditionalIfElseStatementProduction) ElseStatement Statement
				     ;

AbstractCondition ::= (AbstractCondition) Condition;

Condition ::= (ConditionListProduction) Condition OR CondTerm
			| (ConditionProduction) CondTerm
			;				     
			
CondTerm  ::= (CondTermListProduction) CondTerm AND CondFact
			| (CondTermProduction) CondFact
			;
			
FirstCondFact ::= (FirstCondFactProduction) Expr;			
SecondCondFact ::= (SecondCondFactProduction) Expr;
		
CondFact  ::= (CondFactProduction) FirstCondFact RelOp SecondCondFact
		    | (CondFactBoolProduction) Expr
		    ;

RelOp     ::= (RelOpEqProduction) EQ 
		  |	  (RelOpNeProduction) NE
		  |	  (RelOpGrProduction) GR
		  |   (RelOpGreProduction) GRE
		  |   (RelOpLsProduction) LS
		  |   (RelOpLseProduction) LSE
		  ;
		  
StartOfForLoop ::= (StartOfForLoopProduction) FOR LPAREN;
ForLoopStatement ::= (ForLoopStatementProduction) StartOfForLoop OptionalForPrecondition SEMI OptionalForCondition SEMI OptionalForPostcondition RPAREN Statement ;

OptionalForPrecondition ::= (OptionalForPreconditionProduction) DesignatorStatement
						|	(OptionalForPreconditionEpsilonProd) /* epsilon */
						;

OptionalForCondition    ::= (OptionalForConditionProduction) AbstractCondition
						|   (OptionalForConditionEpsilonProd) /* epsilon */
						;
						
OptionalForPostcondition ::= (OptionalForPostconditionProduction) DesignatorStatement
						 |   (OptionalForPostconditionEpsilonProd) /* epsilon */ 
						 ;						
						 
				

