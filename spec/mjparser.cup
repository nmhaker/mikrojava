
package rs.ac.bg.etf.pp1;
import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected;

	Logger log = Logger.getLogger(getClass());
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);	
	}
	
	public void syntax_error(Symbol cur_token){
		report_error("\nSintaksna greska", cur_token);	
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);	
	}
	
	public void report_error(String message, Object info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
			msg.append(" na liniji ").append( ((Symbol)info).left );		
		log.error(msg.toString());
	}
	
:}

init with {:
	errorDetected = false;
:}

/* za presretanje lexera kad god vrati jedan token */
scan with {:
	Symbol s = this.getScanner().next_token();
	if( s!=null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, ENUM, CONST, PRINT, READ, RETURN, NEW;
terminal PLUS, MINUS, MUL, DIV, MOD, INC ,DEC, EQUAL;
terminal DOT, SEMI, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal VOID;
terminal String IDENT;
terminal Integer NUMBER;
terminal boolean BOOL;
terminal String CHARCONST;

nonterminal Statement, StatementList, DesignatorStatement, Designator;
nonterminal SignedTerm, Expr, Term, Factor, Instantiation;
nonterminal Addop, Mulop;
nonterminal MyArray, EnumUse;
nonterminal Program, Type;
nonterminal InstPrimitive, InstArray;
nonterminal VarDeclList, MethDeclList, VarDecl, VarUse, MultipleVarDecl, MultipleVarDeclExpr, MethDecl, ArrayDecl,  EnumExpr, EnumExprList, EnumInst;
nonterminal PrintStmt, PrintParam;
nonterminal Return, OptionalExpr, FuncCall;
nonterminal ConstExpr, ConstInitializationList, ConstDecl;
nonterminal GlobalDeclList, GlobalDecl,  GlobalVarDecl;
nonterminal ParameterList, Parameter, ArgList, OptionalArgs;
nonterminal MethType, EnumDecl;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, EnumBegin, MethBegin;

Program   ::= (Program) PROG ProgName:progName GlobalDeclList LBRACE MethDeclList RBRACE;

ProgName ::= (ProgName) IDENT:progName;

GlobalDeclList ::= (GlobalDeclListProduction) GlobalDeclList GlobalDecl
				|  /* epsilon */
				;

GlobalDecl ::= (GVarDeclList) GlobalVarDecl
			|  (GEnumDeclList) EnumDecl
			|  (GConstDeclList) ConstDecl
			;

GlobalVarDecl  ::=  (GVarDecl) VarDecl
				| 	(GlobalVarDeclErrorComma) error COMMA:l {: parser.report_error("Izvrsen oporavak do prvog ',' u deklaraciji promenljive", null); :} 
				|   (GlobalVarDeclErrorSemi) error SEMI:l {: parser.report_error("Izvrsen oporavak do prve ';' u deklaraciji promneljive", null); :} 
				;

VarDeclList ::= (VarDeclListProduction) VarDeclList VarDecl
			| /* epsilon */
			;
			
MultipleVarDeclExpr ::= (SimpleVarDecl) IDENT:varName
					|   (SimpleArrayDecl) ArrayDecl
					;
					 			
MultipleVarDecl ::= (MultipleVarDeclProduction) MultipleVarDeclExpr COMMA MultipleVarDecl
				| 	(SingleVarDeclProduction) MultipleVarDeclExpr
				; 

VarDecl  ::= (MultipleVariableDecl) Type:varType MultipleVarDecl SEMI
		 ;

MethDeclList ::= (MethDeclListProduction) MethDeclList MethDecl
            |   /* epsilon */
			;

OptionalExpr ::= (OptionalExprProduction) Expr 
			 | /* epsilon */
			 ;

Return ::=  (ReturnProduction) RETURN OptionalExpr SEMI
				;
				
Parameter ::= (ParameterVarProduction) Type IDENT:paramName
			| (ParameterArrayProduction) ArrayDecl
			;
				
ParameterList ::= (MultipleParameterListProduction) Parameter COMMA ParameterList
			  |   (SingleParameterListProduction) Parameter
			  |   /* epsilon */
			  ;
MethType ::= (NonVoidMethType) Type
		 |	 (VoidMethType) VOID 
		 ;				

MethBegin ::= (MethBegin) MethType IDENT:methodName;

MethDecl ::= (MethDecl) MethBegin LPAREN ParameterList RPAREN VarDeclList LBRACE StatementList RBRACE
		;

ArrayDecl ::= (ArrayDecl) IDENT:arrayName LBRACKET RBRACKET ;

ConstExpr ::= (ConstExprNumber) IDENT:constIdent EQUAL NUMBER:constValue
			| (ConstExprBool) IDENT:constIdent EQUAL BOOL:constValue
			| (ConstExprChar) IDENT:constIdent EQUAL CHARCONST:constValue
			;

ConstInitializationList ::= (MultipleConstExpr) ConstExpr COMMA ConstInitializationList
						|   (SingleConstExpr) ConstExpr
						;						

ConstDecl ::= (ConstDecl) CONST Type ConstInitializationList SEMI;

EnumInst ::= (EnumConstValue) EQUAL NUMBER:enumConstantValue
			| (NoEnumInst) /* epsilon */
			;

EnumExpr ::= (EnumExpr) IDENT:enumConstantName EnumInst;

EnumExprList ::= (MultipleEnumExpr) EnumExpr COMMA EnumExprList 
			 | (SingleEnumExpr) EnumExpr
			 ;
EnumBegin ::= (EnumBegin) ENUM IDENT:enumName;			 
EnumDecl ::= (EnumDecl) EnumBegin LBRACE EnumExprList RBRACE;

StatementList ::= (StatementListProduction) StatementList Statement
				|  /* epsilon */
				;
PrintParam ::= (PrintParamProduction) COMMA NUMBER
			|   /* epsilon */
			;
PrintStmt ::=  (PrintStmtProduction) PRINT LPAREN Expr PrintParam RPAREN 
			;

Statement ::=	(DesigStatement) DesignatorStatement SEMI
		  	|   (ReadCall) READ LPAREN Designator RPAREN SEMI
		  	|	(PrintCall) PrintStmt SEMI
		  	|   (MethCall) FuncCall SEMI
		  	|   (ReturnStatement) Return
		    ;

ArgList ::= (ArgumentListProduction) ArgList COMMA Expr
		| (ArgumentListExprProduction) Expr
		;
		
OptionalArgs ::= (OptionalArgsProduction) ArgList
			 | 	/* epsilon */
			 ;
		
FuncCall  ::=  (FuncCall)  IDENT:funcName LPAREN OptionalArgs RPAREN;

DesignatorStatement ::=  (DesStatAssignment) Designator EQUAL Expr
					  |  (DesStatAssignmentError) error:l {: parser.report_error("Izvrsen oporavak u naredbi dodele do prve ';' " , null); :}
					  |	 (DesStatInc) Designator INC
					  |	 (DesStatDec) Designator DEC
					  ;

Expr ::=(AddopExpr) Expr Addop Term
	 |  (TermExpr) SignedTerm
	 ;

SignedTerm ::= (MinusTerm) MINUS Term
			|  (PlusTerm) Term
			;							 

Term ::=  (MulopTerm) Term Mulop Factor
	 |  (FactorTerm) Factor
	 ;

Type ::=  (TypeProduction) IDENT:typeName;

InstPrimitive ::= (InstPrimitive) NEW Type;

InstArray  	  ::= (InstArrayProduction) InstPrimitive LBRACKET Expr RBRACKET;

Instantiation ::= (InstPrimit) InstPrimitive
			    | (InstArr) InstArray;
		
Factor ::= (IdentFactor) VarUse
		 | (NumberFactor) NUMBER
		 | (CharFactor) CHARCONST
		 | (BoolFactor) BOOL
		 | (InstFactor) Instantiation
		 | (ArrayFactor) MyArray
		 | (EnumUseFactor) EnumUse
		 | (FuncCallFactor) FuncCall
		 | (GroupFactor) LPAREN Expr RPAREN
		 ;
		 
VarUse ::= (VarUse) IDENT:varName;
		
MyArray  ::= (MyArray) IDENT:arrName LBRACKET Expr RBRACKET;		

EnumUse   ::= (EnumUse) IDENT:enumName DOT IDENT:enumConst;
		
Designator	::=	(IdentDesignator) VarUse
			|   (MyArrayDesignator) MyArray
			;
		
Addop  ::= (PlusAddop) PLUS 
		|  (MinusAddop) MINUS
		;

Mulop  ::= (MulMulop) MUL
		|  (DivMulop) DIV
		|  (ModMulop) MOD
		;
			
